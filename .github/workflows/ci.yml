name: CI / Release

# Every push to main runs lint+test, then detects whether a new release is
# needed.  If the version in pyproject.toml does not yet have a matching git
# tag, the build matrix fires on Windows and Linux and a GitHub Release is
# created automatically.  PRs only run lint+test.

on:
  push:
    branches: [main]
  pull_request:

permissions:
  contents: write

jobs:
  # ── Lint + Test ──────────────────────────────────────────────────────────────
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: pip

      - name: Install system libraries
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends python3-tk tk-dev

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest ruff pyyaml

      - name: Lint
        run: ruff check .

      - name: Format check
        run: ruff format --check .

      - name: Test
        run: pytest --maxfail=1 --disable-warnings -q

  # ── Detect whether a new release is needed ───────────────────────────────────
  version-check:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    outputs:
      release: ${{ steps.check.outputs.release }}
      version: ${{ steps.check.outputs.version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # need full tag history

      - name: Check if version tag already exists
        id: check
        run: |
          VERSION=$(python - <<'EOF'
          import re
          m = re.search(r'^version\s*=\s*["\']([^"\']+)', open('pyproject.toml').read(), re.M)
          print(m.group(1) if m else '')
          EOF
          )

          if [ -z "$VERSION" ]; then
            echo "release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if git tag --list | grep -qx "v${VERSION}"; then
            echo "Tag v${VERSION} already exists — skipping release."
            echo "release=false" >> "$GITHUB_OUTPUT"
          else
            echo "New version v${VERSION} detected — will release."
            echo "release=true"    >> "$GITHUB_OUTPUT"
            echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          fi

  # ── Build artifacts: Windows and Linux ───────────────────────────────────────
  build:
    needs: version-check
    if: needs.version-check.outputs.release == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            artifact: windows
          - os: ubuntu-latest
            artifact: linux
    runs-on: ${{ matrix.os }}
    env:
      APP_VERSION: ${{ needs.version-check.outputs.version }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.13"
          cache: pip

      - name: Set repo name
        shell: bash
        run: echo "REPO_NAME=${GITHUB_REPOSITORY#*/}" >> "$GITHUB_ENV"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Install Linux system libraries
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends python3-tk tk-dev

      # ── Windows ──────────────────────────────────────────────────────────────
      - name: Generate Windows version resource
        if: runner.os == 'Windows'
        shell: python
        run: |
          import os, textwrap
          v = os.environ["APP_VERSION"].split(".")
          major = int(v[0]); minor = int(v[1] if len(v)>1 else 0); patch = int(v[2] if len(v)>2 else 0)
          repo = os.environ["REPO_NAME"]; ver = os.environ["APP_VERSION"]
          txt = textwrap.dedent(f"""
            VSVersionInfo(
              ffi=FixedFileInfo(
                filevers=({major},{minor},{patch},0), prodvers=({major},{minor},{patch},0),
                mask=0x3f, flags=0x0, OS=0x40004, fileType=0x1, subtype=0x0, date=(0,0)),
              kids=[
                StringFileInfo([StringTable(u'040904B0',[
                  StringStruct(u'CompanyName',      u''),
                  StringStruct(u'FileDescription',  u'{repo}'),
                  StringStruct(u'FileVersion',      u'{ver}'),
                  StringStruct(u'InternalName',     u'{repo}'),
                  StringStruct(u'OriginalFilename', u'{repo}.exe'),
                  StringStruct(u'ProductName',      u'{repo}'),
                  StringStruct(u'ProductVersion',   u'{ver}'),
                ])]),
                VarFileInfo([VarStruct(u'Translation',[1033,1200])])
              ])
          """).strip()
          os.makedirs("packaging", exist_ok=True)
          open("packaging/windows-version.txt","w").write(txt)

      - name: Build Windows app (onedir)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $icon = if (Test-Path "assets/icon.ico") { @("--icon","assets/icon.ico") } else { @() }
          pyinstaller --clean --noconfirm --onedir --windowed `
            @icon `
            --version-file packaging/windows-version.txt `
            --name "$env:REPO_NAME" `
            --hidden-import tkinter `
            --hidden-import _tkinter `
            --add-data "ResilienceReport.qmd;." `
            --add-data "img;img" `
            --add-data "tex;tex" `
            --add-data "_extensions;_extensions" `
            --add-data "references.bib;." `
            --add-data "QTDublinIrish.otf;." `
            --add-data "packaging/setup_dependencies.ps1;." `
            --add-data "packaging/launch_setup.ps1;." `
            app/main.py

      - name: Install NSIS
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          # Search pre-installed locations first
          $candidates = @(
            "C:\Program Files (x86)\NSIS\makensis.exe",
            "C:\Program Files\NSIS\makensis.exe"
          )
          $found = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $found) {
            $cmd = Get-Command makensis -ErrorAction SilentlyContinue
            $found = if ($cmd) { $cmd.Source } else { $null }
          }
          if (-not $found) {
            Write-Host "NSIS not pre-installed, trying winget..."
            winget install NSIS.NSIS --silent `
              --accept-source-agreements --accept-package-agreements
            Write-Host "winget done (rc=$LASTEXITCODE)"   # reset last-exit
            $found = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
          }
          if (-not $found) {
            Write-Host "::error::makensis.exe not found in any expected location"
            exit 1
          }
          Write-Host "NSIS: $found"
          echo "MAKENSIS=$found" >> $env:GITHUB_ENV

      - name: Build Windows installer
        if: runner.os == 'Windows'
        shell: python
        run: |
          import os, subprocess, shutil, textwrap
          repo = os.environ["REPO_NAME"]
          ver  = os.environ["APP_VERSION"]
          # Use absolute paths: NSIS defaults CWD to the script's directory,
          # so relative paths like "dist\foo\" would resolve under packaging\.
          ws     = os.environ.get("GITHUB_WORKSPACE", os.getcwd())
          dist   = os.path.join(ws, "dist")
          bundle = os.path.join(dist, repo)
          nsi = textwrap.dedent(f"""
            Unicode true
            Name "{repo} {ver}"
            OutFile "{dist}\\{repo}-{ver}-windows-setup.exe"
            InstallDir "$PROGRAMFILES64\\{repo}"
            RequestExecutionLevel admin
            Page directory
            Page instfiles
            Section
              SetOutPath "$INSTDIR"
              File /r "{bundle}\\"
              CreateShortcut "$DESKTOP\\{repo}.lnk" "$INSTDIR\\{repo}.exe"
              WriteUninstaller "$INSTDIR\\Uninstall.exe"
              ; Run launch_setup.ps1 synchronously (takes < 1 second).
              ; It registers a Task Scheduler task that runs setup_dependencies.ps1
              ; as SYSTEM — guaranteed elevated, no UAC prompts, no policy blocks.
              ; The heavy setup (R, Quarto, TinyTeX, R packages) then runs in the
              ; background. Progress: C:\ProgramData\ResilienceScan\setup.log
              DetailPrint "Scheduling background dependency setup (R, Quarto, TinyTeX)..."
              DetailPrint "Progress: C:\ProgramData\ResilienceScan\setup.log"
              nsExec::ExecToLog '$WINDIR\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -ExecutionPolicy Bypass -NonInteractive -File "$INSTDIR\\_internal\\launch_setup.ps1" -InstallDir "$INSTDIR"'
              Pop $0
            SectionEnd
            Section "Uninstall"
              Delete "$DESKTOP\\{repo}.lnk"
              Delete "$INSTDIR\\Uninstall.exe"
              RMDir /r "$INSTDIR"
            SectionEnd
          """).lstrip()
          os.makedirs("packaging", exist_ok=True)
          with open("packaging\\installer.nsi", "w") as f:
              f.write(nsi)
          makensis = os.environ.get("MAKENSIS") \
                  or shutil.which("makensis") \
                  or r"C:\Program Files (x86)\NSIS\makensis.exe"
          subprocess.run([makensis, "packaging\\installer.nsi"], check=True)

      - name: Package Windows portable zip
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          Compress-Archive -Path "dist\$env:REPO_NAME\*" `
            -DestinationPath "dist\$env:REPO_NAME-$env:APP_VERSION-windows-portable.zip"

      # ── Linux ─────────────────────────────────────────────────────────────────
      - name: Build Linux app (onedir)
        if: runner.os == 'Linux'
        run: |
          pyinstaller --clean --noconfirm --onedir \
            --name "$REPO_NAME" \
            --hidden-import tkinter \
            --hidden-import _tkinter \
            --add-data "ResilienceReport.qmd:." \
            --add-data "img:img" \
            --add-data "tex:tex" \
            --add-data "_extensions:_extensions" \
            --add-data "references.bib:." \
            --add-data "QTDublinIrish.otf:." \
            app/main.py

      - name: Generate .desktop file
        if: runner.os == 'Linux'
        run: |
          APP_NAME=$(echo "$REPO_NAME" | sed 's/-/ /g; s/\b./\u&/g')
          export APP_NAME
          envsubst < packaging/template.desktop > "packaging/${REPO_NAME}.desktop"

      - name: Package Linux tarball
        if: runner.os == 'Linux'
        run: |
          tar -czf "dist/${REPO_NAME}-${APP_VERSION}-linux-amd64.tar.gz" \
            -C dist "${REPO_NAME}"

      - name: Package AppImage
        if: runner.os == 'Linux'
        run: |
          mkdir -p AppDir/usr/bin
          # Copy the full onedir bundle into the AppImage
          cp -r "dist/$REPO_NAME/"* AppDir/usr/bin/
          cp "packaging/${REPO_NAME}.desktop" AppDir/
          if [ -f "assets/icon.png" ]; then
            cp assets/icon.png "AppDir/${REPO_NAME}.png"
          else
            python -c "
          import struct, zlib
          def chunk(t,d):
            c=struct.pack('>I',len(d))+t+d
            return c+struct.pack('>I',zlib.crc32(c[4:])&0xffffffff)
          sig=b'\x89PNG\r\n\x1a\n'
          open('AppDir/${REPO_NAME}.png','wb').write(
            sig+chunk(b'IHDR',struct.pack('>IIBBBBB',1,1,8,2,0,0,0))
               +chunk(b'IDAT',zlib.compress(b'\x00\xff\x00\x00'))
               +chunk(b'IEND',b''))"
          fi
          wget -q https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool-x86_64.AppImage
          ARCH=x86_64 ./appimagetool-x86_64.AppImage --appimage-extract-and-run \
            AppDir "dist/${REPO_NAME}-${APP_VERSION}-x86_64.AppImage"

      - name: Build .deb package
        if: runner.os == 'Linux'
        run: |
          chmod +x packaging/postinst.sh
          PKG_NAME=$(echo "${REPO_NAME}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          DEB_ROOT="$(pwd)/deb_build"
          mkdir -p "${DEB_ROOT}/DEBIAN"
          mkdir -p "${DEB_ROOT}/opt/${REPO_NAME}"
          mkdir -p "${DEB_ROOT}/usr/bin"
          mkdir -p "${DEB_ROOT}/usr/share/applications"
          cp -r "dist/${REPO_NAME}/." "${DEB_ROOT}/opt/${REPO_NAME}/"
          cp packaging/setup_linux.sh "${DEB_ROOT}/opt/${REPO_NAME}/setup_linux.sh"
          chmod 755 "${DEB_ROOT}/opt/${REPO_NAME}/setup_linux.sh"
          ln -s "/opt/${REPO_NAME}/${REPO_NAME}" "${DEB_ROOT}/usr/bin/${REPO_NAME}"
          cp "packaging/${REPO_NAME}.desktop" "${DEB_ROOT}/usr/share/applications/"
          printf 'Package: %s\nVersion: %s\nArchitecture: amd64\nMaintainer: Windesheim <info@windesheim.nl>\nDescription: ResilienceScan Control Center\n' \
            "$PKG_NAME" "$APP_VERSION" > "${DEB_ROOT}/DEBIAN/control"
          cp packaging/postinst.sh "${DEB_ROOT}/DEBIAN/postinst"
          chmod 755 "${DEB_ROOT}/DEBIAN/postinst"
          dpkg-deb --build --root-owner-group "${DEB_ROOT}" \
            "dist/${REPO_NAME}-${APP_VERSION}-amd64.deb"

      - uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.artifact }}
          path: dist/*

  # ── Create the GitHub Release and attach all artifacts ───────────────────────
  publish:
    needs: [version-check, build]
    runs-on: ubuntu-latest

    steps:
      - uses: actions/download-artifact@v4
        with:
          pattern: release-*
          path: release-assets
          merge-multiple: true

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.version-check.outputs.version }}
          name: v${{ needs.version-check.outputs.version }}
          generate_release_notes: true
          files: release-assets/*

  # ── Patch README download links after release ─────────────────────────────────
  update-readme:
    needs: [version-check, publish]
    runs-on: ubuntu-latest
    env:
      VER: ${{ needs.version-check.outputs.version }}
      REPO: Windesheim-A-I-Support/ResilenceScanReportBuilder

    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Patch download links in README
        run: |
          BASE="https://github.com/${REPO}/releases/download/v${VER}"
          REPO_NAME="${REPO#*/}"

          # Build the replacement block
          NEW_BLOCK="<!-- DOWNLOAD_LINKS_START -->
          | Platform | Download |
          |----------|----------|
          | Windows | [Windows Installer (.exe)](${BASE}/${REPO_NAME}-${VER}-windows-setup.exe) |
          | Windows | [Portable ZIP](${BASE}/${REPO_NAME}-${VER}-windows-portable.zip) |
          | Linux | [.deb (Ubuntu/Debian)](${BASE}/${REPO_NAME}-${VER}-amd64.deb) |
          | Linux | [AppImage](${BASE}/${REPO_NAME}-${VER}-x86_64.AppImage) |
          | Linux | [Tarball (.tar.gz)](${BASE}/${REPO_NAME}-${VER}-linux-amd64.tar.gz) |
          <!-- DOWNLOAD_LINKS_END -->"

          python3 - <<'PYEOF'
          import re, os

          ver      = os.environ["VER"]
          repo     = os.environ["REPO"]
          base     = f"https://github.com/{repo}/releases/download/v{ver}"
          repo_name = repo.split("/")[1]

          block = f"""<!-- DOWNLOAD_LINKS_START -->
          | Platform | Download |
          |----------|----------|
          | Windows | [Windows Installer (.exe)]({base}/{repo_name}-{ver}-windows-setup.exe) |
          | Windows | [Portable ZIP]({base}/{repo_name}-{ver}-windows-portable.zip) |
          | Linux | [.deb (Ubuntu/Debian)]({base}/{repo_name}-{ver}-amd64.deb) |
          | Linux | [AppImage]({base}/{repo_name}-{ver}-x86_64.AppImage) |
          | Linux | [Tarball (.tar.gz)]({base}/{repo_name}-{ver}-linux-amd64.tar.gz) |
          <!-- DOWNLOAD_LINKS_END -->"""

          text = open("README.md", encoding="utf-8").read()
          new_text = re.sub(
              r"<!-- DOWNLOAD_LINKS_START -->.*?<!-- DOWNLOAD_LINKS_END -->",
              block,
              text,
              flags=re.DOTALL,
          )
          open("README.md", "w", encoding="utf-8").write(new_text)
          print(f"README patched for v{ver}")
          PYEOF

      - name: Commit updated README
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          git diff --cached --quiet && echo "No changes" || \
            git commit -m "docs: update download links for v${VER} [skip ci]"
          git push origin main
